<html>
<input type="file" id="file">
<br>
<div id="content"></div>

<script type="text/javascript">
//var file_path = "../img/Bloodstones-Map-1_all_together.svg";
document.getElementById('file').addEventListener('change', function (evt) {
    if (!evt.target.files){
        return;
    }

    var file = evt.target.files ? evt.target.files[0] : null,
        reader = new FileReader();

    reader.onload = function (evt) {
        //console.log(evt.target.result);
		const input = document.getElementById("file");
		input.style.display = "none";
		
		const content = document.getElementById("content");
		//content.innerText = evt.target.result;
		
		//xml parser
		const parser = new DOMParser();
		const svg_fragment = parser.parseFromString(evt.target.result, "image/svg+xml");
		let parent_node = svg_fragment.documentElement;
		
		//remove the defs node
		//console.log(parent_node.children[0]);
		parent_node.removeChild(parent_node.children[0]);
		
		//loop over each separate province movement link, stored as a path node
		var max_iterations = 999999;
		var all_links = [];
		while (parent_node.children.length > 0 && max_iterations > 0)
		{
			//for testing it's easier if we only do a couple
			max_iterations--;
			
			//contruct our JSON object
			var new_move_link = {};
			new_move_link.linked_provinces = [];
			
			//convert the svg path data into our usable format
			let path_node = parent_node.children[0];
			let d_value = path_node.getAttribute("d");
			new_move_link.path_segments = ParseSVGPath(d_value, false);
			console.log(new_move_link.path_segments);
			
			//save the new province
			//console.log(new_prov.name);
			all_links.push(new_move_link);
			
			//remove this g node now that we are done with it
			parent_node.removeChild(path_node);
		}
		
		//export this to plaintext via JSON 
		content.innerText = JSON.stringify(all_links) + ";";
    };

    reader.readAsText(file);
});


function ParseSVGPath (svg_path_string, do_debug)
{
	//console.log("page::ParseSVGPath()");
	//for a good reference see https://css-tricks.com/svg-path-syntax-illustrated-guide/
	//for a good visualiser see https://svg-path-visualizer.netlify.app/
	//applet to test and experiment with regex https://regexr.com/
	
	//in this function, I reinvent the wheel because apparently the svg object handling in js has been deprecated for about 8 years and not replaced yet
	//this is a script parser of the minified svg path d attribute
	//it should be safe because each svg used for province layout is static and will go through a lot of QA testing to identify any issues
	
	//svg_path_string should contain the d (data) attribute for a g (graphics) node inside a svg file
	
	//console.log("page::DrawSVGPath() svg_path_string: " + svg_path_string);
	//console.log("page::DrawSVGPath()");
	
	//cant use string split() because of the different rules for splitting
	//test_element_array = svg_path_string.split(/[a-z]/);
	
	//loop over the string and extract all the elements of the svg path
	path_terms = [];
	
	//loop over each char individually
	var currentPathSeg = {points: [], type: "", absolute: false};
	var allPathSegs = [];
	
	var current_type = "M";
	
	//var working_string = "";
	var current_coord = "";
	for(var c in svg_path_string)
	{
		var current_char = svg_path_string[c];
		
		//first, check if we need to export the current command
		var export_coord = false;
		var export_pathSeg = false;
		if(current_char.search(/[a-zA-Z]/) != -1)
		{
			current_type = current_char;
			current_char = "";
			
			if(currentPathSeg.type != "")
			{
				if(current_coord !== "")
				{
					export_pathSeg = true;
					export_coord = true;
				}
			}
			else
			{
				currentPathSeg.type = current_type;
			}
		}
		else if(currentPathSeg.points.length >= this.GetSVGPathCommandPointsMax(current_type) && currentPathSeg.points[currentPathSeg.points.length - 1].y !== "")
		{
			export_pathSeg = true;
		}
		else if(current_char.search(/[,]/) != -1)
		{
			export_coord = true;
			current_char = "";
		}
		else if(current_char.search(/[-]/) != -1)
		{
			if(current_coord !== "")
			{
				export_coord = true;
			}
		}
		else if(c == svg_path_string.length - 1)
		{
			export_coord = true;
			export_pathSeg = true;
		}
		else if(current_char == "." && current_coord.search(/[.]/) != -1)
		{
			export_coord = true;
		}
		
		if(export_coord)
		{
			//console.log("attempting coord export: " + current_coord);
			if(current_coord[0] === ".")
			{
				current_coord = "0" + current_coord
			}
			else if(current_coord.substring(0,2) === "-.")
			{
				current_coord = current_coord.slice(1);
				current_coord = "-0" + current_coord;
			}
			
			//is this the first point in the segment?
			if(currentPathSeg.points.length === 0)
			{
				//insert a new point in the segment
				currentPathSeg.points.push({x:"",y:""});
			}
			
			//grab the latest point in the segment
			lastPoint = currentPathSeg.points[currentPathSeg.points.length - 1];
			
			//check if the point is finished
			if(lastPoint.y !== "")
			{
				//insert a new point in the segment
				currentPathSeg.points.push({x:"",y:""});
				
				//grab the latest point in the segment
				lastPoint = currentPathSeg.points[currentPathSeg.points.length - 1];
			}
			
			if(lastPoint.x === "")
			{
				var val = Number(current_coord);
				if(do_debug){console.log("exporting " + val + "x but was previously " + current_coord)};
				lastPoint.x = val;
			}
			else if(lastPoint.y === "")
			{
				var val = Number(current_coord);
				if(do_debug){console.log("exporting " + val + "y")};
				lastPoint.y = val;
			}
			else
			{
				console.log("ERROR: ParseSVGPath() expected an unfinished point but found a finished one");
			}
			current_coord = "";
		}
		if(export_pathSeg)
		{
			//does this segment use absolute or relative coordinates?
			//this is currently unused 19/10/23, and i'm trying to avoid using it as much as possible
			if(currentPathSeg.type.search(/[a-z]/) != -1)
			{
				currentPathSeg.absolute = false;
			}
			else if(currentPathSeg.type.search(/[A-Z]/) != -1)
			{
				currentPathSeg.absolute = true;
			}
			else
			{
				//sanity check
				console.log("WARNING: page::DrawSVGPath() unable to determine relative or absolute coords for pathseg with current_type: " + current_type);
			}
			
			if(do_debug){console.log("exported seg: " + JSON.stringify(currentPathSeg))};
			allPathSegs.push(currentPathSeg);
			currentPathSeg = {points: [], type: current_type, absolute: false};
		}
		
		current_coord += current_char;
	}
	
	//console.log(allPathSegs);
	return allPathSegs;
};

function GetSVGPathCommandPointsMax(command)
{
	if(command.search(/[lL]/) != -1)
	{
		return 2;
	}
	if(command.search(/[mM]/) != -1)
	{
		return 2;
	}
	if(command.search(/[zZ]/) != -1)
	{
		return 0;
	}
	if(command.search(/[cC]/) != -1)
	{
		return 3;
	}
	
	console.log("ERROR: page::GetSVGPathCommandPointsMax() unknown command: " + command);
	return 99;
};
</script>

</html>