<html>
<input type="file" id="file">
<br>
<div id="content"></div>

<script type="text/javascript">
//var file_path = "../img/Bloodstones-Map-1_all_together.svg";
document.getElementById('file').addEventListener('change', function (evt) {
    if (!evt.target.files){
        return;
    }

    var file = evt.target.files ? evt.target.files[0] : null,
        reader = new FileReader();

    reader.onload = function (evt) {
        //console.log(evt.target.result);
		const input = document.getElementById("file");
		input.style.display = "none";
		
		const content = document.getElementById("content");
		//content.innerText = evt.target.result;
		
		//xml parser
		const parser = new DOMParser();
		const svg_fragment = parser.parseFromString(evt.target.result, "image/svg+xml");
		let parent_node = svg_fragment.documentElement;
		
		//remove the defs node
		//console.log(parent_node.children[0]);
		parent_node.removeChild(parent_node.children[0]);
		
		//loop over each separate province outline, stored as a g node
		var max_provinces = 9999;
		var all_provinces = [];
		var test_provinces = [];
		while (parent_node.children.length > 0 && max_provinces > 0)
		{
			//for testing it's easier if we only do a couple
			max_provinces--;
			
			//contruct our JSON object
			var new_prov = {};
			new_prov.name = "prov" + all_provinces.length;
			new_prov.type = "Plains";
			new_prov.centre = {x:0,y:0}
			new_prov.movement_links = [];
			new_prov.drag_area_poly = "";
			new_prov.zone = null;
			
			//setup some movement links for testing
			/*
			if(all_provinces.length > 0)
			{
				new_prov.movement_links.push("prov" + (all_provinces.length - 1));
			}
			new_prov.movement_links.push("prov" + (all_provinces.length + 1));
			*/
			
			var do_debug = false;
			var do_debug2 = false;
			if(new_prov.name == "prov0")
			{
				do_debug = true;
				//do_debug2 = true;
			}
			else
			{
				//continue;
			}
			
			//convert the svg path data into our usable format
			var graphics_node = parent_node.children[0];
			if(do_debug)	console.log(graphics_node);
			let path_node = graphics_node.children[0];
			let d_value = path_node.getAttribute("d");
			if(do_debug)	console.log(path_node);
			new_prov.prov_path_segments = ParseSVGPath(d_value, do_debug2);
			if(do_debug)	console.log(new_prov.prov_path_segments);
			
			if(graphics_node.children.length > 1)
			{
				let type_node = graphics_node.children[1];
				//console.log(type_node);

				new_prov.type = type_node.childNodes[0].nodeValue;
				//console.log("new_prov.type: " + new_prov.type);
			}
			
			//calculate the centre of the province using a basic arithmetic mean
			//if the province is weirdly shaped this may place the "centre" at an unintuitive point
			var minX = 9999999;
			var maxX = -9999999;
			var minY = 9999999;
			var maxY = -9999999;
			var cursor = {x:0,y:0};
			for (var i in new_prov.prov_path_segments)
			{
				var seg = new_prov.prov_path_segments[i];
				
				//first, figure out the type of point and thus which set of coords to use
				switch(seg.type)
				{
					case "m":
					{
						cursor.x += seg.points[0].x;
						cursor.y += seg.points[0].y;
						break;
					}
					case "M":
					{
						cursor.x = seg.points[0].x;
						cursor.y = seg.points[0].y;
						break;
					}
					case "c":
					{
						cursor.x += seg.points[2].x;
						cursor.y += seg.points[2].y;
						break;
					}
					case "C":
					{
						cursor.x = seg.points[2].x;
						cursor.y = seg.points[2].y;
						break;
					}
				}
				
				//if(do_debug)	console.log("(" + cursor.x + "," + cursor.y + ")");
				
				if(cursor.x < minX)
				{
					minX = cursor.x;
					//if(do_debug)	console.log("new minX " + minX);
				}
				else if(cursor.x > maxX)
				{
					maxX = cursor.x;
					//if(do_debug)	console.log("new maxX " + maxX);
				}
				if(cursor.y < minY)
				{
					minY = cursor.y;
					//if(do_debug)	console.log("new minY " + minY);
				}
				else if(cursor.y > maxY)
				{
					maxY = cursor.y;
					//if(do_debug)	console.log("new maxY " + maxY);
				}
			}
			new_prov.centre.x = minX + (maxX - minX) / 2;
			new_prov.centre.y = minY + (maxY - minY) / 2;
			if(do_debug)	console.log("centre: " + new_prov.centre.x + "," +  new_prov.centre.y);
			
			//save the new province
			//console.log(new_prov.name);
			all_provinces.push(new_prov);
			if(new_prov.name == "prov2")
			{
				test_provinces.push(new_prov);
			}
			
			//remove this g node now that we are done with it
			parent_node.removeChild(graphics_node);
		}
		
		//for testing
		if(all_provinces.length > 1)
		{
			var last_prov = all_provinces[all_provinces.length - 1];
			last_prov.movement_links = ["prov" + (all_provinces.length - 2)];
		}
		
		//export this to plaintext via JSON 
		content.innerText = JSON.stringify(all_provinces) + ";";
    };

    reader.readAsText(file);
});


function ParseSVGPath (svg_path_string, do_debug)
{
	if(do_debug)	console.log("page::ParseSVGPath()");
	if(do_debug)	console.log(svg_path_string);
	//for a good reference see https://css-tricks.com/svg-path-syntax-illustrated-guide/
	//for a good visualiser see https://svg-path-visualizer.netlify.app/
	//applet to test and experiment with regex https://regexr.com/
	
	//in this function, I reinvent the wheel because apparently the svg object handling in js has been deprecated for about 8 years and not replaced yet
	//this is a script parser of the minified svg path d attribute
	//it should be safe because each svg used for province layout is static and will go through a lot of QA testing to identify any issues
	
	//svg_path_string should contain the d (data) attribute for a g (graphics) node inside a svg file
	
	//console.log("page::DrawSVGPath() svg_path_string: " + svg_path_string);
	//console.log("page::DrawSVGPath()");
	
	//cant use string split() because of the different rules for splitting
	//test_element_array = svg_path_string.split(/[a-z]/);
	
	//loop over the string and extract all the elements of the svg path
	path_terms = [];
	
	//loop over each char individually
	var currentPathSeg = {points: [], type: "", absolute: false};
	var allPathSegs = [];
	
	var current_type = "M";
	
	//var working_string = "";
	var current_coord = "";
	for(var c in svg_path_string)
	{
		var current_char = svg_path_string[c];
		//if(do_debug)	console.log("current_char: " + current_char);
		
		//first, check if we need to export the current command
		var export_coord = false;
		var export_pathSeg = false;
		var cp_max = this.GetSVGPathCommandPointsMax(current_type)
		//if(do_debug)	console.log("cp_max: " + cp_max);
		if(current_char.search(/[a-zA-Z]/) != -1)
		{
			current_type = current_char;
			if(do_debug)	console.log("setting next current_type: " + current_type);
			current_char = "";
			
			if(currentPathSeg.type != "")
			{
				if(current_coord !== "")
				{
					if(do_debug)	console.log("exporting 1 (full)");
					export_pathSeg = true;
					export_coord = true;
				}
				else
				{
				if(do_debug)	console.log("check2");
				}
			}
			else
			{
				currentPathSeg.type = current_type;
				if(do_debug)	console.log("new type");
			}
		}
		else if(currentPathSeg.points.length >= cp_max && currentPathSeg.points[currentPathSeg.points.length - 1].y !== "")
		{
			export_pathSeg = true;
		}
		else if(current_char.search(/[,]/) != -1)
		{
			export_coord = true;
			current_char = "";
		}
		else if(current_char.search(/[-]/) != -1)
		{
			if(current_coord !== "")
			{
				export_coord = true;
			}
		}
		else if(c == svg_path_string.length - 1)
		{
			export_coord = true;
			export_pathSeg = true;
		}
		else if(current_char == "." && current_coord.search(/[.]/) != -1)
		{
			export_coord = true;
		}
		
		if(export_coord)
		{
			//console.log("attempting coord export: " + current_coord);
			if(current_coord[0] === ".")
			{
				current_coord = "0" + current_coord
			}
			else if(current_coord.substring(0,2) === "-.")
			{
				current_coord = current_coord.slice(1);
				current_coord = "-0" + current_coord;
			}
			
			//is this the first point in the segment?
			if(currentPathSeg.points.length === 0)
			{
				//insert a new point in the segment
				currentPathSeg.points.push({x:"",y:""});
			}
			
			//grab the latest point in the segment
			lastPoint = currentPathSeg.points[currentPathSeg.points.length - 1];
			
			//check if the point is finished
			if(lastPoint.y !== "")
			{
				//insert a new point in the segment
				currentPathSeg.points.push({x:"",y:""});
				
				//grab the latest point in the segment
				lastPoint = currentPathSeg.points[currentPathSeg.points.length - 1];
			}
			
			if(lastPoint.x === "")
			{
				var val = Number(current_coord);
				if(do_debug){console.log("exporting " + val + "x but was previously " + current_coord)};
				lastPoint.x = val;
			}
			else if(lastPoint.y === "")
			{
				var val = Number(current_coord);
				if(do_debug){console.log("exporting " + val + "y")};
				lastPoint.y = val;
			}
			else
			{
				console.log("ERROR: ParseSVGPath() expected an unfinished point but found a finished one");
			}
			current_coord = "";
		}
		if(export_pathSeg)
		{
			//does this segment use absolute or relative coordinates?
			//this is currently unused 19/10/23, and i'm trying to avoid using it as much as possible
			if(currentPathSeg.type.search(/[a-z]/) != -1)
			{
				currentPathSeg.absolute = false;
			}
			else if(currentPathSeg.type.search(/[A-Z]/) != -1)
			{
				currentPathSeg.absolute = true;
			}
			else
			{
				//sanity check
				console.log("WARNING: page::DrawSVGPath() unable to determine relative or absolute coords for pathseg with current_type: " + current_type);
			}
			
			if(do_debug){console.log("exported seg: " + JSON.stringify(currentPathSeg))};
			allPathSegs.push(currentPathSeg);
			if(current_type == 'Z')
			{
				//premature finish here
				break;
			}
			currentPathSeg = {points: [], type: current_type, absolute: false};
		}
		
		current_coord += current_char;
	}
	
	//console.log(allPathSegs);
	return allPathSegs;
};

function GetSVGPathCommandPointsMax(command)
{
	if(command.search(/[lL]/) != -1)
	{
		return 2;
	}
	if(command.search(/[mM]/) != -1)
	{
		return 2;
	}
	if(command.search(/[sS]/) != -1)
	{
		return 2;
	}
	if(command.search(/[zZ]/) != -1)
	{
		return 0;
	}
	if(command.search(/[cC]/) != -1)
	{
		return 3;
	}
	
	console.log("ERROR: page::GetSVGPathCommandPointsMax() unknown command: " + command);
	return 99;
};
</script>

</html>